(function(){
  'use strict';
  var crypto, Url, extend, ref$, map, unchars, defaults, digest, query, path, hexUrl, this$ = this;
  crypto = require('crypto');
  Url = require('url');
  extend = require('xtend');
  ref$ = require('prelude-ls'), map = ref$.map, unchars = ref$.unchars;
  defaults = {
    host: 'http://localhost:8081',
    key: '0x24FEEDFACEDEADBEEFCAFE',
    type: 'query'
  };
  digest = curry$((function(key, data){
    var hmac;
    hmac = crypto.createHmac('sha1', key);
    hmac.update(data);
    return hmac.digest('hex');
  }), true);
  query = function(d, host, url){
    var q;
    q = '?url=' + encodeURIComponent(url);
    return Url.resolve(host, d) + q;
  };
  path = function(d, host, url){
    return Url.resolve(host, d) + '/' + hexUrl(url);
  };
  hexUrl = function(url){
    var buffer, bytes, this$ = this;
    buffer = new Buffer(url, 'utf-8');
    bytes = Array.prototype.slice.call(buffer);
    return unchars(
    map(function(it){
      return it.toString(16);
    })(
    bytes));
  };
  module.exports = function(options){
    var converter, fn;
    options = extend(defaults, options);
    converter = (function(){
      switch (options.type) {
      case 'query':
        return query;
      case 'path':
        return path;
      }
    }());
    fn = function(url){
      var d;
      d = digest(options.key, url);
      return converter(d, options.host, url);
    };
    fn.digest = digest(options.key);
    return fn;
  };
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
